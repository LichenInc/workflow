var gulp        = require('gulp');
var runSequence = require('run-sequence');
var path        = require('path');

var configs          = gulp_require('config');
var handleErrors     = gulp_require('util/handleErrors');

var iconfont     = lazy_require('gulp-iconfont');
var swig         = lazy_require('gulp-swig');
var rename       = lazy_require('gulp-rename');
var plumber      = lazy_require('gulp-plumber');
var cond         = lazy_require('gulp-cond');
var size         = lazy_require('gulp-size');

var watch        = lazy_require('gulp-watch');
var batch        = lazy_require('gulp-batch');
var browserSync  = lazy_require('browser-sync');



function generateIconSass(fontname, config) {

  return function(codepoints, options) {
    gulp.src('./gulp/tasks/icons/iconFonts/template.sass.swig')
      .pipe(cond()(global.watching, function(){ return plumber()(handleErrors.plumber('Icon-fonts sass error ' + fontname)) }))
      .pipe(swig()({
        data: {
          icons: codepoints.map(function(icon) {
            return {
              name: icon.name,
              code: icon.codepoint.toString(16)
            }
          }),
          fontName: fontname,
          fontPath: config.fontPath,
          className: config.className,
          comment: 'DO NOT EDIT DIRECTLY!\n  Generated by gulp'
        }
      }))
      .pipe(rename()(config.sassOutputName))
      .pipe(gulp.dest(config.sassDest));
  };

}

function iconFontTask(config){

  return gulp.src(config.src)
    .pipe(cond()(global.watching, function(){ return plumber()(handleErrors.plumber('Icon-fonts error ' + config.name)) }))
    .pipe(iconfont()(config.options))
    .on('codepoints', generateIconSass(config.options.fontName, config.sass))
    .pipe(gulp.dest(path.join((global.distribution ? configs.dirs.dist : configs.dirs.app), configs.dirs.fonts, config.dest)))
    .pipe(cond()(global.distribution, function(){ return size()({title: 'icon-fonts: ' + config.name}) } ))
    .pipe(cond()(global.watching, function(){ return browserSync().reload({stream:true}) }));

}

module.exports = iconFontTask;

if (!configs.iconFonts) return;

gulp.task('iconFont', function(cb){
  runSequence(configs.iconFonts.map(function (config) {
    var task = 'iconFont:' + config.name

    gulp.task(task, function () {
      return iconFontTask(config)
    });

    return task
  }), cb);
});

// Watch task

function watchIconFontsTask(config){
  watch()([config.src],
    { name: 'Watch icon fonts sources: ' + config.name },
    batch()(function (events, done) {
      gulp.start('iconFont:' + config.name);
      done();
    }));
}

var watchIconFontsTasks = configs.iconFonts.map(function (config) {
  var task = 'watch:iconFont:' + config.name

  gulp.task(task, function () {
    return watchIconFontsTask(config)
  });

  return task
});

gulp.task('watch:iconFont', function(cb){
  runSequence(watchIconFontsTasks, cb);
});
